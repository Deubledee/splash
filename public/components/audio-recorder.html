<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<dom-module id="audio-recorder">
    <template>
        <style include="shared-styles-typeG">
            :host { width: 100%; margin-right: var(--app-standart-border-radius); } article { box-shadow: var( --app-toolbar-box-shadow);
            border-radius: var(--app-standart-border-radius); margin-top: 6px; width: 164px; background-color: var(--app-primary-background-color);
            padding-left: 9px; display: flex; flex-flow: column; } iron-input { flex-basis: 25px; } span, label[for=range]
            { color: var(--app-color) } .open[open] { height: auto } audio { width: 128px } paper-icon-button { color: var(--app-color)
            } paper-icon-button[record] { display: block } paper-icon-button { display: none } .red { color: var(--app-color-3)
            } .red[paused] { color: initial } section[list-box-hiden] { display: none } section[list-box-hiden][boxShow]
            { display: block } paper-button { font-size: var(--app-type-button-font-size); } aside[apllyWith] { border-top:
            0.4px solid #b6b6b6b3 } paper-icon-button[play] { display: block; color: var(--app-type-sellected-background-color)
            } paper-icon-button[disable] { display: block; color: #b6b6b6b3 } paper-item[sellected] { background-color: chartreuse
            } paper-icon-button[pause] { display: none } paper-icon-button[icon="query-builder"] { display: block } #progress
            { background-color: transparent; height: 0px; width: 0px } #progress[progress] { background-color: rgb(255, 0,
            0); height: 1px; }
        </style>
        <article>
            <label for="range">[[elemTitle]]
                <span>[[type]]</span>
                <button on-click="removeCall"> x </button>
            </label>
            <section id="title" class="open" open$="[[!open]]">
                <paper-item>
                    <paper-item-body two-line>
                        <paper-input class="diferent" title="Elapsed time" label="[[state]]" value="{{Elapsed}}">
                        </paper-input>
                        <audio id="audio" class="diferent" title="Elapsed Time" on-timeupdate="timeupdate" label="Elapsed Time">
                        </audio>
                    </paper-item-body>
                    <paper-icon-button on-click="toggleTimeView" icon="query-builder" title="toggle time view"></paper-icon-button>
                </paper-item>
                <aside apllyWith>
                    <paper-item>
                        <paper-item-body two-line>
                        </paper-item-body>
                        <paper-icon-button id="apllyNow" on-click="toggleRecording" icon="radio-button-checked" class="red" record$="[[record]]"
                            paused$="[[paused]]" title="toggle recording">
                        </paper-icon-button>
                        <paper-icon-button id="apllyNow" on-click="toggleRecording" icon="radio-button-unchecked" record$="[[!record]]" title="toggle recording">
                        </paper-icon-button>
                        <paper-icon-button icon="av:play-arrow" record$="[[record]]" disable$="[[disable]]" title="play recorded - opens new File Source">
                        </paper-icon-button>
                        <paper-icon-button icon="file-download" record$="[[record]]" disable$="[[disable]]" title="play recorded - opens new File Source">
                        </paper-icon-button>
                        <paper-icon-button on-click="playRecording" icon="av:play-arrow" play$="[[play]]" title="play recorded - opens new File Source">
                        </paper-icon-button>
                        <paper-icon-button on-click="downloadRecording" icon="file-download" play$="[[play]]" title="play recorded - opens new File Source">
                        </paper-icon-button>
                    </paper-item>
                </aside>
                <div id="progress" progress$="[[progress]]"></div>
                <aside apllyWith>
                    <paper-menu-button>
                        <paper-button slot="dropdown-trigger" alt="menu">aplly with</paper-button>
                        <paper-listbox slot="dropdown-content">
                            <template id="applyNode" is="dom-repeat" items="{{keys}}" as="key" mutable-data="true">
                                <paper-item on-click="showBox">[[key]]</paper-item>
                            </template>
                        </paper-listbox>
                    </paper-menu-button>
                </aside>
            </section>
            <section list-box-hiden boxShow$="[[boxShow]]" on-click="hidewBox2">
                <paper-listbox id="listBox" slot="dropdown-content" multi>
                    <template is="dom-repeat" items="{{applicables}}" as="applicable" mutable-data="true">
                        <paper-item id='[[applicable.name]]' on-click="hidewBox">[[applicable.titleFuncion]]</paper-item>
                    </template>
                </paper-listbox>
            </section>
            <div class="open divtitle-area" open$="[[open]]">
                <section id="title" class="open" open$="[[open]]">
                    <paper-input class="diferent" id="titleInput" min="0" max="5" step="0.5" label="new title" title="new title" value="{{elemTitle}}">
                    </paper-input>
                    <paper-button on-click="submit" raised>aplly title </paper-button>
                </section>
            </div>
        </article>
    </template>
    <script>
        const options = {
            timeLimit: 300, //timeLimit * 60,
            encodeAfterRecord: true,
            progressInterval: 1000, //progressInterval * 1000,
            ogg: {
                quality: 0.4
            },
            mp3: {
                bitRate: 128
            }
        }

        class audioRecorder extends Polymer.Element {
            static get is() {
                return 'audio-recorder';
            }
            constructor() {
                super();
            }
            ready() {
                super.ready()
                window.addEventListener('apllywith', (event) => {
                    this.applyer()
                }, false)
                window.addEventListener('connected', (event) => {
                    if (this.elemTitle === event.detail.connected) {
                        this.connected = event.detail.state
                        console.log(this.connected)
                        if (this.record === true && this.connected === false) {
                            this.cancelRecording()
                        }
                    }
                }, false)
            }
            static get properties() {
                return {
                    timeView: {
                        type: Boolean,
                        value: true
                    },
                    Elapsed: {
                        type: String,
                        value: '00:00'
                    },
                    elapAnimation: {
                        type: Number
                    },
                    state: {
                        type: String,
                        value: 'inactive...'
                    },
                    disable: {
                        type: Boolean,
                        value: true,
                        notify: true,
                        reflectToAttribute: true
                    },
                    progress: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    play: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    boxShow: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    applicables: {
                        type: Array,
                        value: function () {
                            return []
                        },
                        notify: true
                    },
                    keys: {
                        type: Array,
                        value: function () {
                            return []
                        },
                        notify: true
                    },
                    type: {
                        type: String,
                        value: 'Destination'
                    },
                    sellected: {
                        type: Array,
                        value: []
                    },
                    elemTitle: {
                        type: String
                    },
                    titleFuncion: {
                        type: String,
                        value: 'destination'
                    },
                    agentClass: {
                        type: Object
                    },
                    constraints: {
                        type: Object,
                        value: function () {
                            return { audio: true }
                        }
                    },
                    record: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    paused: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    pause: {
                        type: Boolean,
                        value: true,
                        notify: true,
                        reflectToAttribute: true
                    },
                    open: {
                        type: Boolean,
                        value: true,
                        notify: true,
                        reflectToAttribute: true
                    },
                    count: {
                        type: Number
                    },
                    recorder: {
                        type: Object
                    },
                    recordedAudio: {
                        type: Array,
                        value: [0]
                    },
                    kill: {
                        type: Boolean,
                        value: false
                    },
                    progressTime: {
                        type: Boolean,
                        value: false
                    },
                    blob: {
                        type: Object
                    },
                    blob2: {
                        type: Object
                    }
                }
            }

            applyer() {
                this.keys = [0]
                let keys = Object.keys(this.agentClass.applicables)
                let arr = [], arr2 = []
                for (let i = 0; i < keys.length; i++) {
                    if (keys[i] === this.elemTitle && this.agentClass.applicables[keys[i]].arr.length > 1) {
                        arr.push(keys[i])
                    }
                    if (keys[i] !== this.elemTitle) {
                        arr.push(keys[i])
                    }
                }
                //  console.log('apllied')
                this.keys = arr
            }

            showBox(event) {
                this.boxShow = true
                this.applicables = [0]
                let arr2 = []
                let name = this.elemTitle + this.titleFuncion.split(' ').join('').toLocaleUpperCase()
                for (let j = 0; j < this.agentClass.applicables[event.model.__data.key].arr.length; j++) {
                    if (this.agentClass.applicables[event.model.__data.key].arr[j].name !== name) {
                        arr2.push(this.agentClass.applicables[event.model.__data.key].arr[j])
                    }
                }
                this.applicables = arr2
                setTimeout(() => {
                    this.shouldSellect(this.sellected, this.applicables)
                }, 25)
            }

            shouldSellect(arr1, arr2) {
                let itIs = []
                console.log('shouldSellect', arr1, arr2)
                arr1.map(item => {
                    for (let i = 0; i < arr2.length; i++) {
                        if (item.name === arr2[i].name) {
                            this.sellect(this.$.listBox.children, arr2[i].name)
                        }
                        if (item.name !== arr2[i].name) {
                            this.unSellect(this.$.listBox.children, arr2[i].name)
                        }
                    }
                })
            }

            hidewBox2(event) {
                this.boxShow = false
            }

            sellect(elem, name) {
                if (name === undefined) {
                    elem.setAttribute('sellected', true)
                    console.log('sellected', elem[name], name)
                } else {
                    elem[name].setAttribute('sellected', true)
                    console.log('sellected', elem[name], name)
                }
            }

            unSellect(elem, name) {
                if (name === undefined) {
                    elem.removeAttribute('sellected', true)
                    console.log('unsellected', elem[name], name)
                } else {
                    elem[name].removeAttribute('sellected', true)
                    console.log('unsellected', elem[name], name)
                }
            }
            popFromArray(item) {
                let arr = []
                for (let i = 0; i < this.sellected.length; i++) {
                    if (this.sellected[i].name !== item) {
                        arr.push(this.sellected[i])
                    }
                }
                this.sellected = arr
                console.log('popfrom', this.sellected, arr)
            }
            hidewBox(event) {
                this.boxShow = false
                let bool = event.model.children[1].hasAttribute('sellected') === true ? false : true
                let name = event.model.__data.applicable.elemTitle + event.model.__data.applicable.titleFuncion.split(' ').join('').toLocaleUpperCase()
                if (bool === true) {
                    this.agentClass.setAppliesWith((err) => {
                        if (event.model.children[1].innerHTML === event.model.__data.applicable.titleFuncion) {
                            console.log('sellected here now..!', event.model.children[1].innerHTML, event.model.__data.applicable.titleFuncion)
                            this.sellected.push({ name: name, sellected: true })
                            this.sellect(event.model.children[1])
                            console.log('pusheed..!', this.sellected)
                        }
                    }, { elemTitle: this.elemTitle, name: name, elem: this.$.apllyNow, titleFuncion: this.titleFuncion, sellected: true })
                    // console.log(event.model.children[1], name, this.titleFuncion, event)
                }
                if (bool === false) {
                    this.agentClass.revoveAppliesWith((err) => {
                        if (err) console.error(err)
                        //    console.log(bool)
                        this.popFromArray(name)
                        this.unSellect(event.model.children[1])
                    }, { elemTitle: this.elemTitle, name: name, titleFuncion: this.titleFuncion, sellected: false })
                }
            }

            _minSecStr(n) {
                return (n < 10 ? "0" : "") + n;
            };

            timeupdate(time) {
                let timeUpdate = time | 0
                timeUpdate = (this._minSecStr(timeUpdate / 60 | 0)) + ":" + (this._minSecStr(timeUpdate % 60))
                this.Elapsed = timeUpdate
            }

            toggleTimeView() {
                this.timeView = !this.timeView
            }

            toggleRecording() {
                this.record = !this.record
                if (this.recorder && this.record === true) {
                    let that = this.agentClass
                    this.disable = true
                    this.play = false
                    let name = this.elemTitle + this.titleFuncion.split(' ').join('').toLocaleUpperCase()
                    var inter = setInterval(() => {
                        if (this.kill == true) {
                            clearInterval(inter)
                            this.kill = false
                        } else {
                            this.paused = !this.paused
                            this._hasRecordingStarted(that, name)
                        }
                    }, 500)

                    this.recorder.onError = this.error
                    this.recorder.onComplete = (this.handleStop).bind(this);
                    this.recorder.onEncodingProgress = (this.setProgress).bind(this);
                    this.recorder.onEncodingCanceled = (this.cancelRecording).bind(this)
                    this.recorder.onTimeout = (this.handleStop).bind(this);

                    this.recorder.setOptions(options);
                    this.recorder.startRecording();
                } else {
                    if (this.disable === true) {
                        this.recorder.finishRecording()
                        this.state = 'inactive...'
                        this.Elapsed = '00:00'
                    } else {
                        this.cancelRecording();
                    }
                }
            }

            _hasRecordingStarted(that, name) {
                //  console.log(this.recorder.isRecording())
                if (this.recorder.isRecording() === true && this.connected === true) {
                    this.paused = false
                    this.kill = true
                    this.record = true
                    this.state = 'recording...'
                    this.__startTime()
                    this.play = false
                    if (that.appliesWith[name]) {
                        for (let i = 0; i < that.appliesWith[name].length; i++) {
                            that.appliesWith[name][i].elem.click()
                        }
                    }
                } else {
                    // this.paused = true
                    this.state = 'connecting...!'
                    this.Elapsed = 'no connection'
                }
            }
            __startTime() {
                var inter = setInterval(() => {
                    if (this.kill == true) {
                        clearInterval(inter)
                        this.kill = false
                    } else {
                        this.timeupdate(this.recorder.recordingTime())
                    }
                }, 500)
            }

            setProgress(recorder, progress) {
                var percent;
                this.progress = true
                this.kill = true
                percent = (progress * 100).toFixed(1) + "%";
                //  console.log(percent, this.$.progress)
                this.state = 'encoding...'
                this.Elapsed = percent
                this.$.progress.style.width = percent
                setTimeout(() => {
                    if ((progress * 100) === 100) {
                        this.progress = false
                        this.disable = false
                        this.play = true
                        this.state = 'Play/Download'
                        this.Elapsed = 'done...'
                        setTimeout(() => {
                            this.displayToDefault()
                        }, 3000)
                    }
                }, 1000)
            }

            cancelRecording() {
                this.state = 'canceled...'
                this.recorder.cancelRecording();
                setTimeout(() => {
                    this.displayToDefault()
                }, 1000)
            }

            displayToDefault() {
                this.kill = false
                this.state = 'inactive...'
                this.Elapsed = '00:00'
                this.record = false
            }

            handleStop(rec, blob) {
                this.blob = blob
                this.kill = true
                //  this.disable = false
            }

            playRecording() {

                
            }

            downloadRecording() {
                var url = window.URL.createObjectURL(this.blob);
                var a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = new Date().toISOString() + '-splash.mp3';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a)
            }

            toggleRecordingPause() {
                this.pause = !this.pause
                this.paused = !this.paused
                if (this.recorder && this.pause === false) {
                    this.recorder.pause()
                    this.state = this.recorder.state
                } else {
                    this.recorder.resume()
                    this.state = this.recorder.state
                }
            }

            submit() {
                if (this.$.titleInput.value.length > 0) {
                    this.elemTitle = this.elemTitle.split(' ').join('')
                    this.agentClass.gain((err, mixer) => {
                        if (typeof err === 'object') {
                            throw this.error('input ', err);
                        } else if (typeof err === 'string') {
                            this.$.titleInput.value = 'already exists'
                            throw this.error('input ', err);
                            setTimeout(() => {
                                this.$.titleInput.value = ''
                                this.elemTitle = ''
                            }, 1000)
                        }
                        if (err === false) {
                            window.dispatchEvent(new CustomEvent('elemem-title', { detail: { title: this.elemTitle } }))
                            let name = this.elemTitle + this.titleFuncion.split(' ').join('').toLocaleUpperCase()
                            this.agentClass.setApplicable(() => {
                                //     console.log('typeFuncion', this.typeFuncion)
                                window.addEventListener('apllywith', (event) => {
                                    this.applyer()
                                }, false)
                                window.dispatchEvent(new CustomEvent('apllywith', { detail: { title: this.elemTitle } }))
                            }, {
                                    elemTitle: this.elemTitle,
                                    arr: [{
                                        elemTitle: this.elemTitle,
                                        titleFuncion: this.titleFuncion,
                                        name: name
                                    }]
                                })
                            this.open = false
                            this.recorder = new WebAudioRecorder(mixer, {
                                workerDir: '/public/scripts/'
                            })
                            this.recorder.setEncoding('mp3')
                        }
                    }, this.elemTitle, true)
                }
            }

            error(msg, err) {
                console.error(msg, err);
            }

            removeCall() {
                if (this.open === false) {
                    this.agentClass.revoveElemTitle(() => {
                        window.dispatchEvent(new CustomEvent('apllywith', { detail: { title: this.elemTitle } }))
                        delete this.agentClass.streamNode[this.elemTitle]
                        this.parentElement.removeChild(this)
                        window.dispatchEvent(new CustomEvent('elemem-title', { detail: { title: this.elemTitle } }))
                    }, this.elemTitle)
                    //  console.log(this, this.parentElement)
                } else {
                    alert('insert tytle to remove item')
                }
            }
        }
        window.customElements.define(audioRecorder.is, audioRecorder);
    </script>
</dom-module>